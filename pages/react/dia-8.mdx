import ReactDOM from "react-dom";
import Inspector from "react-inspector";
import DevTools from "../../components/devtools.js";
import withLayout from "../../lib/with-layout.js";

export const meta = {
  title: "Componentes con Hijos Personalizables",
  day: 8,
  date: "",
  description: "¡Aprende React haciendo un ejercicio al día durante 100 días!",
  slug: "/react/dia-1",
  lang: "es",
  tags: ["Frontend", "React", "JavaScript"]
}

export default withLayout("react-daily")(meta)

[Ayer creamos `Header` e hicimos que renderice `Hello` internamente](/react/dia-7). Hoy vamos a hacer que el contenido de `Header` se pueda personalizar como un prop de forma que podamos decidir si usar Header o no.

Esto además nos va a evitar el uso de prop drilling, pero ¿Por qué querríamos evitar esto? En nuestro caso no hay ningún problema con usar prop drilling, pero a medida que agregemos más y más componentes que reciban y pasen props a sus hijos esto se puede llegar a volver un problema debido a que:

- Complicaría refactorizar nuestros datos (props).
- Terminaríamos pasando más props de los necesarios para evitar problemas de olvidarnos un prop.
- No pasaríamos props que si son necesarios debido al abuso de `defaultProps`.
- Dificultaría seguir el flujo de props en nuestra aplicación si terminamos renombrando props a mitad de camino.

Todo esto se puede evitar haciendo lo que vamos a hacer eso.

```js
function Header(props) {
  return React.createElement(
    'header',
    null,
    React.createElement(Hello, { name: props.name })
  );
}

Header.propTypes = {
  name: PropTypes.string
};

Header.defaultProps = {
  name: "Mundo"
};
```

Ese es nuestro `Header`, vamos a hacer que en vez de recibir el prop `name` reciba un prop que vamos a llamar `children` y vamos a usar hacerlo obligatorio.

```js
function Header(props) {
  return React.createElement('header', null, props.children);
}

Header.propTypes = {
  children: PropTypes.node.isRequired
};
```

Como vemos pasamos `props.children` como tercer elemento de `React.createElement`, esto es porque el contenido, como lo definimos en nuestros propTypes, es un nodo de React por lo que es cualquier cosa que sirva como hijo de un ejemplo.

Si actualizamos el ejemplo usando nuestro nuevo `Header` quedaría así:

```js
function Hello(props) {
  return React.createElement('h1', null, `Hola ${props.name}!`);
}

Hello.propTypes = {
  name: PropTypes.string
};

Hello.defaultProps = {
  name: "Mundo"
};

function Header(props) {
  return React.createElement('header', null, props.children);
}

Header.propTypes = {
  children: PropTypes.node.isRequired
};

const element = React.createElement(Header, {
  children: React.createElement(Hello, { name: "Sergio" })
});
const node = document.getElementById("app");

ReactDOM.render(
  element,
  node
);
```

Como vemos ahora `Header` no sabe que `Hello` recibe un prop `name`, el solo recibe `Hello` como su prop `children` y lo coloca dentro de `<header>`.

Con esto acabamos de mejorar como nuestro componente se compone de otros componentes lo que permitiría que Header reciba cualquier otro componente o elemento de React y lo envuelva en la etiqueta `<header>`.

[¡Mañana vamos a ver por qué llamamos `children` a nuestro prop!](/react/dia-9)