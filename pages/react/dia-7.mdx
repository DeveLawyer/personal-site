import ReactDOM from "react-dom";
import Inspector from "react-inspector";
import DevTools from "../../components/devtools.js";
import withLayout from "../../lib/with-layout.js";

export const meta = {
  title: "Composición de Componentes en React",
  day: 7,
  date: "",
  description: "¡Aprende React haciendo un ejercicio al día durante 100 días!",
  slug: "/react/dia-1",
  lang: "es",
  tags: ["Frontend", "React", "JavaScript"]
}

export default withLayout("react-daily")(meta)

Hasta ahora [hemos creado un solo componente](/react/dia-3), lo más normal al usar React es tener múltiples componentes y combinarlos para formar un componente más complejo. Hoy vamos a ver como hacer esto.

Si [recordamos de ayer](/react/dia-6) nuestro componente debe lucir así:

```js
function Hello(props) {
  return React.createElement('h1', null, `Hola ${props.name}!`);
}

Hello.propTypes = {
  name: PropTypes.string
};

Hello.defaultProps = {
  name: "Mundo"
};
```

Vamos a crear un componente `Header` que renderice `Hello` internamente y agregue una etiqueta `<header>` alrededor de nuestro `<h1>`.

```js
function Header(props) {
  return React.createElement(
    'header',
    null,
    React.createElement(Hello, { name: props.name })
  );
}

Header.propTypes = {
  name: PropTypes.string
};

Header.defaultProps = {
  name: "Mundo"
};
```

Si vemos acabamos de crear nuestro nuevo componente que [crea un elemento](/react/dia-2) `<header>` y dentro de este crea un elemento usando el componente `Hello`, además de esto hicimos que este nuevo componente reciba el prop `name` y se lo pase tal cual a `Hello`.

> **Nota**: Pasar props de un componente padre a un componente hijo se conoce como prop drilling o threading. Más adelante veremos algunos problemas de esta técnica y como solucionarlos, pero es importante entender que **no es una mala práctica** hacerlo.

Esto es llama composición de componente, el nombre viene de Programación Funcional donde existe la técnica Composición de Funciones. La idea es que uses funciones, o en nuestro caso componentes, más pequeños y simples para crear funciones/componentes más complejos.

De esta forma podríamos tener varios componentes que usen internamente `Hello` para crear diferentes resultados agregando más contenido alrededor de este.

Si ahora actualizamos nuestro código quedaría así:

```js
function Hello(props) {
  return React.createElement('h1', null, `Hola ${props.name}!`);
}

Hello.propTypes = {
  name: PropTypes.string
};

Hello.defaultProps = {
  name: "Mundo"
};

function Header(props) {
  return React.createElement(
    'header',
    null,
    React.createElement(Hello, { name: props.name })
  );
}

Header.propTypes = {
  name: PropTypes.string
};

Header.defaultProps = {
  name: "Mundo"
};

const element = React.createElement(Header, { name: "Sergio" });
const node = document.getElementById("app");

ReactDOM.render(
  element,
  node
);
```

¡Con esto acabas de crear tu segundo componente! [Mañana veremos como mejorar Header para personalizar el contenido dentro de `<header>`](/react/dia-8).
