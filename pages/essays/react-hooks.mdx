import withLayout from "../../lib/with-layout.js";

export const meta = {
  title: "Introducción a React Hooks",
  date: "2018-10-24T17:32:04.452Z",
  description: "Aprende a usar Hooks de React en tus aplicaciones y preparate para el futuro",
  slug: "react-hooks",
  published: true,
  lang: "es",
  tags: [
    "JavaScript",
    "Async",
    "Memoize",
    "React",
    "Hooks"
  ]
}

export default withLayout("essay")(meta)

Hooks es una propuesta de un nuevo feature para React que está disponible para usar ya mismo instalando `react@next` y `react-dom@next` o `@v16.7.0-alpha` que es la versión exacta y en caso de ser aceptada va a ser liberada en la versiǿn `16.7`.

Los hooks vienen con la idea de ser una solución para varios problemas al usar React como son la dificultad de reusar lógica entre componente, componentes complejos que se vuelven difíciles de entender y el simple hecho de que usar clases hace más difícil que usar funciones directamente.

## Adopción Gradual

Algo importante es que los Hooks son _**completamente opcionales**_ y no es necesario usarlos, se puede y se va a poder seguir usando y actualizando React sin problemas mientras se usan clases en vez de hooks.

## Usando hooks: `useState`

Veamos como usar un hooks, para esto vamos a comparar clases y hooks haciendo el mismo código, una componente que mantiene el estado de un input y lo actualiza cuando se escribe en el.

```js
import React, { Component } from "react";

class Input extends Component {
  state = {
    value: this.props.defaultValue,
  };

  handleChange = event => {
    this.setState({
      value: event.target.value
    });
  }

  render() {
    const { value } = this.state;
    return (
      <input value={value} onChange={this.handleChange} />
    );
  }
}
```

Así es como se vería nuestro componente. Ahora veamos como se haría usando Hooks.

```js
import React, { useState } from "react";

function Input({ defaultValue }) {
  const [value, setValue] = useState(defaultValue);
  function handleChange(event) {
    setValue(event.target.value);
  }
  return (
    <input value={value} onChange={handleChange} />
  );
}
```

¿Cómo funciona? El hook `useState` nos permite pasar un valor por inicial a nuestro estado y nos devuelve un array, el primer elemento de dicho array es el valor actual y el segundo es la función para actualizar, como `this.setState`, este array lo descomponemos en `value` y `setValue`, el nombre puede ser el que quieras para ambos.

> _Nota_: Se usa un array y no un objeto debido a que el objeto tendría nombres para sus propiedades haciendo más largo ponerles cualquier nombre al necesitar hacer `{ state: value, setState: setValue } = useState(defaultValue)`, especialmente al usar múltiples `useState`.

Después creamos la función para manejar el evento `change` que usa `setValue` y devolvemos el input usando `value` y nuestro `handleChange`. Con esto React va a crear el estado de nuestro componente y actualizarlo cada vez que `handleChange` se ejecute, al actualizarse el estado se va a volver a renderizar `Input`.

Exactamente igual que como funcionan las clases, pero sin el overhead de hacer `extend`, un método `render` y el uso de `this`, cosa que quizás para un desarrollador con experiencia en React sea fácil mas para un desarrollador que está aprendiendo React y capaz que hasta JavaScript puede ser más complicado.

### Múltiples estados

Ya vimos como funciona, que ocurre queremos usar un estado más complejo y con varias propiedades? Una opción es pasar un objeto como estado inicial y después encargarse de actualizar solo ciertas propiedades, de forma similar a como funciona `this.setState`.

```js
const [state, setState] = useState({ value: '', count: 0 });
function handleChange(event) {
  setState({
    ...state,
    value: event.target.value
  });
}
function handleClick() {
  setState({
    ...state,
    count: state.count + 1
  });
}
```

Y aunque esto funciona no es ideal, lo mejor en este caso es simplemente usar `useState` dos veces para tener dos estado.

```js
const [count, setCount] = useState(0);
const [value, setValue] = useState('');
function handleChange(event) {
  setValue(event.target.value);
}
function handleClick() {
  setCount(count + 1);
}
```

> _Nota_: El órden en el que se ejecutan los `useState` es importante, si este cambiara React podría pasar el valor de count a value y viceversa. Es _muy raro_ que cambie el orden, pero es importante tenerlo en cuenta por si pasa.

## Usando hooks: `useEffect`

Ya vimos como reemplazar el uso del estado con hooks, ahora veamos como reemplazar el uso de los métodos del ciclo de vida con estos. Para eso tenemos un hooks llamado `useEffect` que nos permite realizar efectos o más específicamente efectos secundarios.

Este hook se ejecuta **después** de cada render del componente lo que lo hace similar a `componentDidMount` y `componentDidUpdate`. Veamos un ejemplo con clases y con el hook.

```js
import React, { Component } from "react";

class Count extends Component {
  state = {
    count: 0,
  }
  componentDidMount() {
    document.title = `Clicks: ${this.state.count}`;
  }
  componentDidUpdate() {
    document.title = `Clicks: ${this.state.count}`;
  }
  handleClick = () => {
    this.setState(state => ({ count: state.count + 1 }));
  }
  render() {
    return (
      <button onClick={this.handleClick}>Clicks: {this.state.count};
    )
  }
}
```

Nuestro componente `Count` cuenta los clicks y actualiza el título de la página para indicar la cantidad de clicks realizados. Veamos ahora como hacerlo con hooks.

```js
import React, { useState, useEffect } from "react";

function Count() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `Clicks: ${count}`;
  });

  return (
    <button onClick={() => setCount(state.count + 1)}>Clicks: {count};
  );
}
```

Como vemos `useEffect` recibe una función y la ejecuta después de cada render lo que lo vuelve un reemplazo no solo de `componentDidMount` sino también de `componentDidUpdate`. Como extra las funciones que se ejecutan en `useEffect` no impiden que el navegador actualize la pantalla por lo que proveen un mejor rendimiento.

### Limpieza de efectos

En algunos casos es posible que necesitemos hacer una limpieza al desmontar el componente. Digamos que queremos escuchar todos los clicks de la página ahora en vez de un solo botón, para esto con clases usaríamos `componentDidMount` para agregar un event listener y `componentWillUnmount` para eliminarlo.

```js
import React, { Component } from "react";

class ClickCounter extends Component {
  state = {
    count: 0
  };

  componentDidMount() {
    window.addEventListener('click', this.handleClick);
  }

  componentWillUnmount() {
    window.removeEventListener('click', this.handleClick);
  }

  handleClick = () => {
    this.setState(state => ({ count: state.count + 1 }));
  };

  render() {
    return (
      <p>Clicks: {this.state.count}</p>
    )
  }
}
```

Estos se puede lograr usando hooks. Veamos como.

```js
import React, { useState, useEffect } from "react";

function ClickCounter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  useEffect(() => {
    window.addEventListener('click', handleClick);
    return () => window.removeEventListener('click', handleClick);
  });

  return (
    <p>Clicks: {count}</p>
  );
}
```

Movemos la función que actualiza nuestro estado por fuera de `useEffect` y realizamos el `addEventListener` dentro de esto. Adicionalmente devolvemos una función que ejecuta `removeEventListener`. React va a ejecutar esta función después de desmontar y antes de actualizar el componente por lo que entre cada render se va a eliminar el listener anterior y agregar uno nuevo, cuando no haya un nuevo render simplemente va a eliminar el último listener.

Con esto podemos ejecutar código después del montado, después de una actualización y antes de desmontar.

> _Nota_: La razón de que se ejecute `removeEventListener` antes del update es debido a que si nuestro efecto se basa en datos que llegan por `props` y estos cambian es necesario en `componentDidUpdate` volver a agregar nuestros listener. Esto se puede evitar como veremos más adelante.

### Múltiples efectos

En caso de que necesitemos realizar varios efectos dentro de un mismo componente es posible usar un solo `useEffect` para ejecutarlos a todos o lo que es mejor y recomendado usar este hooks una vez por cada efecto para tener una mejor separación de responsabilidades.

```js
import React, { useState, useEffect } from "react";

function ClickCounter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  // listen clicks
  useEffect(() => {
    window.addEventListener('click', handleClick);
    return () => window.removeEventListener('click', handleClick);
  });

  // update title
  useEffect(() => {
    document.title = `Clicks: ${count}`;
  });

  return (
    <p>Clicks: {count}</p>
  );
}
```

Con esto podemos mantener más separados los efectos según su uso.

### Obviando efectos

Antes dijimos que nuestros efectos se ejecutan y se limpian después de cada render. En caso de que no necesitemos que esto pase en `componentDidUpdate` teníamos acceso a los props y el estado anterior y nos permitía condicionar si se debería volver a agregar a realizar un efecto.

Usando hooks esto es posible pasando un segundo argumento a `useEffect`.

```js
import React, { useState, useEffect } from "react";

function ClickCounter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  // listen clicks
  useEffect(() => {
    window.addEventListener('click', handleClick);
    return () => window.removeEventListener('click', handleClick);
  }, []);

  // update title
  useEffect(() => {
    document.title = `Clicks: ${count}`;
  }, [count]);

  return (
    <p>Clicks: {count}</p>
  );
}
```

Agregando este segundo argumento `[count]` podemos indicar que si `count` o cualquier valor ya sea estado o props no cambia entonces el efecto no debe ejecutarse.

En el caso de actualizar el título simplemente el título no se va a cambiar si la cantidad de clicks no cambian. En el caso de suscribirnos a los click de la ventana al pasar este array vacío se evitar eliminar y volver a agregar el listener de eventos en cada update, solo agregándose en el montado y eliminándose en el desmontado.

## Reglas de los Hooks

Para poder usar hooks hay ciertas reglas que se deben tener en cuenta. El equipo de React liberó un plugin de ESLint para detectar si alguna de estas reglas no se cumple.

Lo pueden descargar como `eslint-plugin-react-hooks` usando yarn o npm y agregar a su configuración usando:

```json
{
  "plugins": [
    // ...
    "react-hooks"
  ],
  "rules": {
    // ...
    "react-hooks/rules-of-hooks": "error"
  }
}
```

### Solo usarlos en el nivel superior del componente

Los hooks solo puede ser usados directo en el component y no dentro de ciclos, condiciones u otras funciones.

```js
function Component(props) {
  if (props.condition) {
    const [state, setState] = useState();
  }
}
```

El código de arriba es inválido ya que `useState` no puede ejecutarse en una condición. Si queremos ejecutar un hook como `useEffect` dentro de una condición debemos poner la condición dentro del hook.

### Solo ejecutar hooks en funciones de React

No se pueden usar hooks en funciones regulares, solo dentro de una función de React, estos son:

- Componentes de React
- Hooks personalizados

## Creando un hook personalizado

Recién dijimos que es posible ejecutar un hook dentro de otro hook personalizado. Vamos a ver como extraer la lógica de nuestros hooks anteriores usando hooks personalizados.

```js
useEffect(() => {
  document.title = `Clicks: ${count}`;
}, [count]);
```

Vamos a empezar con este efecto, para esto tenemos creamos una función llamada `useTitle` y dentro ejecutar nuestro hook, recibiendo `message` como argumento.

> _Nota_: Todos los hooks deben empezar con `use` y algo más.

```js
import { useEffect } from "react";

function useTitle(message) {
  useEffect(() => {
  document.title = message
}, [message]);
}
```

Ahora podemos cambiar nuestro componente para usar nuestro nuevo hook.

```js
import React, { useState, useEffect } from "react";
import useTitle from "./use-title";

function ClickCounter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  // listen clicks
  useEffect(() => {
    window.addEventListener('click', handleClick);
    return () => window.removeEventListener('click', handleClick);
  }, []);

  // update title
  useTitle(`Clicks: ${count}`);

  return (
    <p>Clicks: {count}</p>
  );
}
```

Veamos ahora como extraer nuestro otro efecto.

```js
import { useEffect } from "react";

function useListener(event, handler) {
  useEffect(() => {
    window.addEventListener(event, handler);
    return () => window.removeEventListener(event, handler);
  }, []);
}
```

Ahora podemos actualizar nuestro componente para usar este segundo hook personalizado.

```js
import React, { useState } from "react";
import useTitle from "./use-title";
import useListener from "./use-listener";

function ClickCounter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  // listen clicks
  useListener("click", handleClick);

  // update title
  useTitle(`Clicks: ${count}`);

  return (
    <p>Clicks: {count}</p>
  );
}
```

Como vemos a `useListener` le pasamos tanto el evento como el handler, esto es para poder usar nuestro hook para varios tipos de eventos globales, no solo click, y para que la función que usemos para manejar los eventos tengo dentro de su scope `setCount` y `count` y ser capaz de actualizar el estado.

Podríamos llevar esto un paso más allá y crear otro hook que envuelva a nuestro dos hooks personalizados y a useState.

```js
import { useState } from "react";
import useListener from "./use-listener";
import useTitle from "./use-title";

function useCounter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  // listen clicks
  useListener("click", handleClick);

  // update title
  useTitle(`Clicks: ${count}`);

  // return current counter
  return count;
}
```

Y para usarlo.

```js
import React from "react";
import useCounter from "./use-counter";

function Counter() {
  const count = useCounter();
  return (
    <p>Clicks: {count}</p>
  );
}
```

Con esto extrajimos la lógica de nuestro componente en un hook personalizado el cual a su vez está compuesto de otros dos hooks personalizados.

## Aún. Más. Hooks.

Hay más hooks a parte de los mencionados arriba que son más secundarios.

### `useContext`

Este hook nos permite obtener un valor por contexto, para usarlo hay que pasar un contexto creado con `React.createContext`.

```js
import React, { useContext } from "react";
import context from "./context";

function Counter() {
  const count = useContext(context);
  return (
    <p>Clicks: {count}</p>
  );
}
```

